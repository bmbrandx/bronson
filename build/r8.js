// Generated by CoffeeScript 1.3.1
(function() {
  var __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  (function(root, factory) {
    if (typeof define === "function" && define.amd) {
      return define([], factory);
    } else {
      return root.R8 = factory(root.b);
    }
  })(this, function() {
    var Api, Core, Permissions, R8;
    R8 = window.R8 = {
      version: "0.0.1"
    };
    Api = R8.Api = {
      subscribe: function(subscriber, channel, callback) {
        if (Permissions.validate(subscriber, channel)) {
          return Core.subscribe(subscriber, channel, callback);
        } else {
          return console.error("Core#subscribe: Subscriber " + subscriber + " not allowed to listen on channel " + channel);
        }
      },
      unsubscribe: function(subscriber, channel) {
        return Core.unsubscribe(subscriber, channel);
      },
      publish: function(channel) {
        return Core.publish(channel);
      },
      createModule: function() {
        var callback, moduleId, obj, _i;
        moduleId = arguments[0], obj = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
        return Core.createModule(moduleId, obj, callback);
      },
      stopAllModules: function() {
        return Core.stopAllModules();
      },
      stopModule: function(moduleId) {
        return Core.stopModule(moduleId);
      }
    };
    Permissions = R8.Permissions = {
      _enabled: false,
      enabled: function(value) {
        return this._enabled = !!value;
      },
      rules: {},
      extend: function(props) {
        var rules;
        return rules = $.extend(true, {}, props, this);
      },
      validate: function(subscriber, channel) {
        var test, _ref;
        if (this._enabled) {
          test = (_ref = this.rules[subscriber]) != null ? _ref[channel] : void 0;
          if (test === void 0) {
            return false;
          } else {
            return test;
          }
        } else {
          return true;
        }
      }
    };
    Core = R8.Core = {
      channels: {},
      modules: {},
      subscribe: function(subscriber, channel, callback) {
        if (!(subscriber != null) || !(channel != null) || !(callback != null)) {
          throw new Error('R8.Core#subscribe: subscriber, channel, callback must be defined');
        }
        if (typeof channel !== "string") {
          throw new Error("R8.Core#subscribe: channel must be a string");
        }
        if (typeof subscriber !== "string") {
          throw new Error("R8.Core#subscribe: subscriber must be a string");
        }
        if (typeof callback !== "function") {
          throw new Error("R8.Core#subscribe: callback must be a function");
        }
        this.channels[channel] = (!this.channels[channel] ? [] : this.channels[channel]);
        this.channels[channel].push({
          subscriber: subscriber,
          callback: callback
        });
        return console.log("Core#subscribe: Subscribing subscriber: " + subscriber + " to channel: " + channel);
      },
      unsubscribe: function(subscriber, channel) {
        var i, item, _i, _len, _ref, _results;
        _ref = this.channels[channel];
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          item = _ref[i];
          console.log(item, i);
          if (item.subscriber === subscriber) {
            _results.push(this.channels[channel].splice(i, 1));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      publish: function(channel) {
        var args, subscriber, subscribers, _i, _len, _results;
        if (!(channel != null)) {
          throw new Error("Core#publish: channel must be defined");
        }
        if (typeof channel !== "string") {
          throw new Error("Core#publish: channel must be a string");
        }
        if (!this.channels[channel]) {
          return true;
        }
        subscribers = this.channels[channel].slice();
        args = [].slice.call(arguments, 1);
        _results = [];
        for (_i = 0, _len = subscribers.length; _i < _len; _i++) {
          subscriber = subscribers[_i];
          subscriber.callback.apply(this, args);
          _results.push(console.log("Core#publish: Publishing event to " + channel));
        }
        return _results;
      },
      createModule: function() {
        var callback, moduleId, obj, _i,
          _this = this;
        moduleId = arguments[0], obj = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
        if (moduleId === 'undefined') {
          throw new Error("Core#createModule: moduleId must be defined");
        }
        if (typeof moduleId !== 'string') {
          throw new Error("Core#createModule: moduleId must be a string");
        }
        obj = obj[0];
        return require([moduleId], function(module) {
          console.log('moduleId', moduleId);
          console.log(_this.modules['test']);
          module = new module(obj);
          _this.modules['test'] = module;
          callback(module);
          return console.log("Core#createModule: Creating module " + moduleId + " successful");
        });
      },
      stopAllModules: function() {
        var id, _results;
        _results = [];
        for (id in modules) {
          _results.push(this.stopModule(id));
        }
        return _results;
      },
      stopModule: function(moduleId) {
        var ch, i, mod;
        mod = modules[moduleId];
        if (mod) {
          for (ch in this.channels) {
            if (this.channels.hasOwnProperty(ch)) {
              i = 0;
              while (i < this.channels[ch].length) {
                if (this.channels[ch][i].subscriber === moduleId) {
                  this.channels[ch].splice(i);
                }
                i++;
              }
            }
          }
          return console.log("AKQA.Application.Core#stopModule: successfully stopped module " + moduleId);
        } else {
          throw new Error("AKQA.Application.Core#stopModule: unable to stop nonexistent module");
        }
      }
    };
    R8.Module = (function() {

      Module.name = 'Module';

      Module.prototype.view = null;

      Module.prototype.currentId = null;

      Module.prototype.disposed = false;

      function Module() {
        this.initialize.apply(this, arguments);
      }

      Module.prototype.initialize = function() {};

      Module.prototype.dispose = function() {
        var obj, prop, properties, _i, _len;
        if (this.disposed) {
          return;
        }
        for (prop in this) {
          if (!__hasProp.call(this, prop)) continue;
          obj = this[prop];
          if (obj && typeof obj.dispose === 'function') {
            obj.dispose();
            delete this[prop];
          }
        }
        properties = ['currentId'];
        for (_i = 0, _len = properties.length; _i < _len; _i++) {
          prop = properties[_i];
          delete this[prop];
        }
        this.disposed = true;
        return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
      };

      return Module;

    })();
    return R8;
  });

}).call(this);
